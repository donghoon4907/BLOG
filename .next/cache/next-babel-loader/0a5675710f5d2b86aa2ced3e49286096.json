{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\nimport { ApolloClient, InMemoryCache, createHttpLink, split, ApolloLink } from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\nimport { onError } from \"@apollo/client/link/error\";\nimport { WebSocketLink } from \"@apollo/client/link/ws\";\nimport { getMainDefinition } from \"@apollo/client/utilities\";\nimport { TokenRefreshLink } from \"apollo-link-token-refresh\";\nimport jwtDecode from \"jwt-decode\";\nimport fetch from \"isomorphic-unfetch\";\nimport Router from \"next/router\";\nimport Head from \"next/head\";\nimport { getAccessToken, setAccessToken } from \"./token\";\nimport isBrowser from \"./isBrowser\";\nexport function withApollo(PageComponent) {\n  const WithApollo = (_ref) => {\n    let {\n      apolloClient,\n      apolloState\n    } = _ref,\n        pageProps = _objectWithoutProperties(_ref, [\"apolloClient\", \"apolloState\"]);\n\n    const client = apolloClient || initApolloClient(apolloState);\n    return __jsx(PageComponent, _extends({}, pageProps, {\n      apolloClient: client\n    }));\n  };\n\n  if (false) {\n    // Find correct display name\n    const displayName = PageComponent.displayName || PageComponent.name || \"Component\"; // Warn if old way of installing apollo is used\n\n    if (displayName === \"App\") {\n      console.warn(\"This withApollo HOC only works with PageComponents.\");\n    } // Set correct display name for devtools\n\n\n    WithApollo.displayName = `withApollo(${displayName})`;\n  }\n\n  if (!isBrowser || PageComponent.getInitialProps) {\n    WithApollo.getInitialProps = async context => {\n      const {\n        AppTree,\n        ctx: {\n          res\n        }\n      } = context; // Run all GraphQL queries in the component tree\n      // and extract the resulting data\n\n      const apolloClient = context.ctx.apolloClient = initApolloClient({});\n      const pageProps = PageComponent.getInitialProps ? await PageComponent.getInitialProps(context) : {}; // Only on the server\n\n      if (!isBrowser) {\n        // When redirecting, the response is finished.\n        // No point in continuing to render\n        if (res && res.finished) {\n          return {};\n        }\n\n        if (!isBrowser) {\n          try {\n            // Run all GraphQL queries\n            const {\n              getDataFromTree\n            } = await import(\"@apollo/react-ssr\");\n            await getDataFromTree(__jsx(AppTree, {\n              pageProps: _objectSpread(_objectSpread({}, pageProps), {}, {\n                apolloClient\n              }),\n              apolloClient: apolloClient\n            }));\n          } catch (error) {\n            // Prevent Apollo Client GraphQL errors from crashing SSR.\n            // Handle them in components via the data.error prop:\n            // https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-query-data-error\n            console.error(\"Error while running `getDataFromTree`\", error);\n          }\n        } // getDataFromTree does not call componentWillUnmount\n        // head side effect therefore need to be cleared manually\n\n\n        Head.rewind();\n      } // Extract query data from the Apollo store\n\n\n      const apolloState = apolloClient.cache.extract();\n      return _objectSpread(_objectSpread({}, pageProps), {}, {\n        apolloState\n      });\n    };\n  }\n\n  return WithApollo;\n}\nlet apolloClient = null; // Polyfill fetch() on the server (used by apollo-client)\n\nif (!isBrowser) {\n  global.fetch = fetch;\n}\n/**\n * Creates and configures the ApolloClient\n * @param  {Object} [initialState={}]\n * @param  {Object} config\n */\n\n\nfunction createApolloClient(initialState = {}) {\n  const httpLink = createHttpLink({\n    uri: process.env.BACKEND_API_PATH\n  });\n  const wsLink = isBrowser ? new WebSocketLink({\n    uri: `${process.env.BACKEND_WS_PATH}`,\n    options: {\n      reconnect: true\n    }\n  }) : null;\n  const refreshLink = new TokenRefreshLink({\n    accessTokenField: \"accessToken\",\n    isTokenValidOrUndefined: () => {\n      const token = getAccessToken();\n\n      if (!token) {\n        return true;\n      }\n\n      try {\n        const {\n          exp\n        } = jwtDecode(token);\n\n        if (Date.now() >= exp * 1000) {\n          return false;\n        } else {\n          return true;\n        }\n      } catch {\n        return false;\n      }\n    },\n    fetchAccessToken: () => {\n      const token = getAccessToken();\n      return fetch(`${process.env.BACKEND_API_PATH}/refresh_token`, {\n        method: \"POST\",\n        headers: {\n          Authentication: `Bearer ${token}`\n        }\n      });\n    },\n    handleFetch: accessToken => {\n      setAccessToken(accessToken);\n    },\n    handleError: err => {\n      console.error(err);\n      Router.replace(\"/login\");\n    }\n  });\n  const splitLink = isBrowser ? split(({\n    query\n  }) => {\n    const definition = getMainDefinition(query);\n    return definition.kind === \"OperationDefinition\" && definition.operation === \"subscription\";\n  }, wsLink, httpLink) : httpLink;\n  const errorLink = onError(({\n    graphQLErrors,\n    networkError\n  }) => {\n    if (graphQLErrors) graphQLErrors.map(({\n      message,\n      path\n    }) => {\n      console.log(`[GraphQL error] Query: ${path}, ${message}`);\n      const response = JSON.parse(message);\n\n      if (isBrowser && response.status === 401) {\n        Router.replace(\"/login\");\n      }\n    });\n\n    if (networkError) {\n      console.log(`[Network error]: ${networkError}`);\n\n      if (isBrowser) {\n        alert(\"서버 점검 중입니다.\");\n        Router.replace(\"/login\");\n      }\n    }\n  });\n  const authLink = setContext((_, {\n    headers\n  }) => {\n    const token = getAccessToken();\n    return {\n      headers: _objectSpread(_objectSpread({}, headers), {}, {\n        Authorization: `Bearer ${token}`\n      })\n    };\n  });\n  const link = [errorLink, authLink, isBrowser ? httpLink : splitLink];\n\n  if (isBrowser) {\n    link.unshift(refreshLink);\n  }\n\n  return new ApolloClient({\n    connectToDevTools: isBrowser,\n    ssrMode: !isBrowser,\n    // Disables forceFetch on the server (so queries are only run once)\n    //link: errorLink.concat(authLink.concat(isBrowser ? httpLink : splitLink)),\n    link: ApolloLink.from(link),\n    cache: new InMemoryCache().restore(initialState)\n  });\n} // export function initializeApollo(initialState: any, options: Options) {\n//   // Make sure to create a new client for every server-side request so that data\n//   // isn't shared between connections (which would be bad)\n//   if (!isBrowser) {\n//     return createApolloClient(initialState, options);\n//   }\n//   // Reuse client on the client-side\n//   if (!apolloClient) {\n//     apolloClient = createApolloClient(initialState, options);\n//   }\n//   return apolloClient;\n// }\n\n/**\n * Always creates a new apollo client on the server\n * Creates or reuses apollo client in the browser.\n */\n\n\nfunction initApolloClient(initialState) {\n  // Make sure to create a new client for every server-side request so that data\n  // isn't shared between connections (which would be bad)\n  if (!isBrowser) {\n    return createApolloClient(initialState);\n  } // Reuse client on the client-side\n\n\n  if (!apolloClient) {\n    // setAccessToken(cookie.parse(document.cookie).test);\n    apolloClient = createApolloClient(initialState);\n  }\n\n  return apolloClient;\n}","map":null,"metadata":{},"sourceType":"module"}