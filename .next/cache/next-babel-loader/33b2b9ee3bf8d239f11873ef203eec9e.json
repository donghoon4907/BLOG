{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\nimport { ApolloClient, InMemoryCache, createHttpLink, split, ApolloLink } from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\nimport { onError } from \"@apollo/client/link/error\";\nimport { WebSocketLink } from \"@apollo/client/link/ws\";\nimport { getMainDefinition } from \"@apollo/client/utilities\";\nimport { TokenRefreshLink } from \"apollo-link-token-refresh\";\nimport jwtDecode from \"jwt-decode\";\nimport fetch from \"isomorphic-unfetch\";\nimport Router from \"next/router\";\nimport Head from \"next/head\";\nimport { getAccessToken, setAccessToken } from \"./token\";\nimport isBrowser from \"./isBrowser\";\nexport function withApollo(PageComponent) {\n  const WithApollo = (_ref) => {\n    let {\n      apolloClient,\n      apolloState\n    } = _ref,\n        pageProps = _objectWithoutProperties(_ref, [\"apolloClient\", \"apolloState\"]);\n\n    const client = apolloClient || initApolloClient(apolloState);\n    return __jsx(PageComponent, _extends({}, pageProps, {\n      apolloClient: client\n    }));\n  };\n\n  if (true) {\n    // Find correct display name\n    const displayName = PageComponent.displayName || PageComponent.name || \"Component\"; // Warn if old way of installing apollo is used\n\n    if (displayName === \"App\") {\n      console.warn(\"This withApollo HOC only works with PageComponents.\");\n    } // Set correct display name for devtools\n\n\n    WithApollo.displayName = `withApollo(${displayName})`;\n  }\n\n  if (!isBrowser || PageComponent.getInitialProps) {\n    WithApollo.getInitialProps = async context => {\n      const {\n        AppTree,\n        ctx: {\n          res\n        }\n      } = context; // Run all GraphQL queries in the component tree\n      // and extract the resulting data\n\n      const apolloClient = context.ctx.apolloClient = initApolloClient({});\n      const pageProps = PageComponent.getInitialProps ? await PageComponent.getInitialProps(context) : {}; // Only on the server\n\n      if (!isBrowser) {\n        // When redirecting, the response is finished.\n        // No point in continuing to render\n        if (res && res.finished) {\n          return {};\n        }\n\n        if (!isBrowser) {\n          try {\n            // Run all GraphQL queries\n            const {\n              getDataFromTree\n            } = await import(\"@apollo/react-ssr\");\n            await getDataFromTree(__jsx(AppTree, {\n              pageProps: _objectSpread(_objectSpread({}, pageProps), {}, {\n                apolloClient\n              }),\n              apolloClient: apolloClient\n            }));\n          } catch (error) {\n            // Prevent Apollo Client GraphQL errors from crashing SSR.\n            // Handle them in components via the data.error prop:\n            // https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-query-data-error\n            console.error(\"Error while running `getDataFromTree`\", error);\n          }\n        } // getDataFromTree does not call componentWillUnmount\n        // head side effect therefore need to be cleared manually\n\n\n        Head.rewind();\n      } // Extract query data from the Apollo store\n\n\n      const apolloState = apolloClient.cache.extract();\n      return _objectSpread(_objectSpread({}, pageProps), {}, {\n        apolloState\n      });\n    };\n  }\n\n  return WithApollo;\n}\nlet apolloClient = null; // Polyfill fetch() on the server (used by apollo-client)\n\nif (!isBrowser) {\n  global.fetch = fetch;\n}\n/**\n * Creates and configures the ApolloClient\n * @param  {Object} [initialState={}]\n * @param  {Object} config\n */\n\n\nfunction createApolloClient(initialState = {}) {\n  const httpLink = createHttpLink({\n    uri: process.env.BACKEND_API_PATH\n  });\n  const wsLink = isBrowser ? new WebSocketLink({\n    uri: `${process.env.BACKEND_WS_PATH}`,\n    options: {\n      reconnect: true\n    }\n  }) : null;\n  const refreshLink = new TokenRefreshLink({\n    accessTokenField: \"accessToken\",\n    isTokenValidOrUndefined: () => {\n      const token = getAccessToken();\n\n      if (!token) {\n        return true;\n      }\n\n      try {\n        const {\n          exp\n        } = jwtDecode(token);\n\n        if (Date.now() >= exp * 1000) {\n          return false;\n        } else {\n          return true;\n        }\n      } catch {\n        return false;\n      }\n    },\n    fetchAccessToken: () => {\n      const token = getAccessToken();\n      return fetch(`${process.env.BACKEND_API_PATH}/refresh_token`, {\n        method: \"POST\",\n        headers: {\n          Authentication: `Bearer ${token}`\n        }\n      });\n    },\n    handleFetch: accessToken => {\n      setAccessToken(accessToken);\n    },\n    handleError: err => {\n      console.error(err);\n      Router.replace(\"/login\");\n    }\n  });\n  const splitLink = isBrowser ? split(({\n    query\n  }) => {\n    const definition = getMainDefinition(query);\n    return definition.kind === \"OperationDefinition\" && definition.operation === \"subscription\";\n  }, wsLink, httpLink) : httpLink;\n  const errorLink = onError(({\n    graphQLErrors,\n    networkError\n  }) => {\n    if (graphQLErrors) graphQLErrors.map(({\n      message,\n      path\n    }) => {\n      console.log(`[GraphQL error] Query: ${path}, ${message}`);\n      const response = JSON.parse(message);\n\n      if (isBrowser && response.status === 401) {\n        Router.replace(\"/login\");\n      }\n    });\n\n    if (networkError) {\n      console.log(`[Network error]: ${networkError}`);\n\n      if (isBrowser) {\n        alert(\"서버 점검 중입니다.\");\n        Router.replace(\"/login\");\n      }\n    }\n  });\n  const authLink = setContext((_, {\n    headers\n  }) => {\n    const token = getAccessToken();\n    return {\n      headers: _objectSpread(_objectSpread({}, headers), {}, {\n        Authorization: `Bearer ${token}`\n      })\n    };\n  });\n  const link = [authLink, errorLink, splitLink];\n\n  if (isBrowser) {\n    link.push(refreshLink);\n  }\n\n  return new ApolloClient({\n    connectToDevTools: isBrowser,\n    ssrMode: !isBrowser,\n    // Disables forceFetch on the server (so queries are only run once)\n    //link: errorLink.concat(authLink.concat(isBrowser ? httpLink : splitLink)),\n    link: ApolloLink.from(link),\n    cache: new InMemoryCache().restore(initialState)\n  });\n} // export function initializeApollo(initialState: any, options: Options) {\n//   // Make sure to create a new client for every server-side request so that data\n//   // isn't shared between connections (which would be bad)\n//   if (!isBrowser) {\n//     return createApolloClient(initialState, options);\n//   }\n//   // Reuse client on the client-side\n//   if (!apolloClient) {\n//     apolloClient = createApolloClient(initialState, options);\n//   }\n//   return apolloClient;\n// }\n\n/**\n * Always creates a new apollo client on the server\n * Creates or reuses apollo client in the browser.\n */\n\n\nfunction initApolloClient(initialState) {\n  // Make sure to create a new client for every server-side request so that data\n  // isn't shared between connections (which would be bad)\n  if (!isBrowser) {\n    return createApolloClient(initialState);\n  } // Reuse client on the client-side\n\n\n  if (!apolloClient) {\n    // setAccessToken(cookie.parse(document.cookie).test);\n    apolloClient = createApolloClient(initialState);\n  }\n\n  return apolloClient;\n}","map":{"version":3,"sources":["/Users/idonghun/Desktop/vss/frontend/lib/apollo.tsx"],"names":["React","ApolloClient","InMemoryCache","createHttpLink","split","ApolloLink","setContext","onError","WebSocketLink","getMainDefinition","TokenRefreshLink","jwtDecode","fetch","Router","Head","getAccessToken","setAccessToken","isBrowser","withApollo","PageComponent","WithApollo","apolloClient","apolloState","pageProps","client","initApolloClient","displayName","name","console","warn","getInitialProps","context","AppTree","ctx","res","finished","getDataFromTree","error","rewind","cache","extract","global","createApolloClient","initialState","httpLink","uri","process","env","BACKEND_API_PATH","wsLink","BACKEND_WS_PATH","options","reconnect","refreshLink","accessTokenField","isTokenValidOrUndefined","token","exp","Date","now","fetchAccessToken","method","headers","Authentication","handleFetch","accessToken","handleError","err","replace","splitLink","query","definition","kind","operation","errorLink","graphQLErrors","networkError","map","message","path","log","response","JSON","parse","status","alert","authLink","_","Authorization","link","push","connectToDevTools","ssrMode","from","restore"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport {\n  ApolloClient,\n  InMemoryCache,\n  createHttpLink,\n  split,\n  NormalizedCacheObject,\n  ApolloLink\n} from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\nimport { onError } from \"@apollo/client/link/error\";\nimport { WebSocketLink } from \"@apollo/client/link/ws\";\nimport { getMainDefinition } from \"@apollo/client/utilities\";\nimport { TokenRefreshLink } from \"apollo-link-token-refresh\";\nimport jwtDecode from \"jwt-decode\";\nimport fetch from \"isomorphic-unfetch\";\nimport Router from \"next/router\";\nimport Head from \"next/head\";\nimport { getAccessToken, setAccessToken } from \"./token\";\nimport isBrowser from \"./isBrowser\";\n\nexport function withApollo(PageComponent: any) {\n  const WithApollo = ({ apolloClient, apolloState, ...pageProps }: any) => {\n    const client = apolloClient || initApolloClient(apolloState);\n    return <PageComponent {...pageProps} apolloClient={client} />;\n  };\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // Find correct display name\n    const displayName =\n      PageComponent.displayName || PageComponent.name || \"Component\";\n\n    // Warn if old way of installing apollo is used\n    if (displayName === \"App\") {\n      console.warn(\"This withApollo HOC only works with PageComponents.\");\n    }\n\n    // Set correct display name for devtools\n    WithApollo.displayName = `withApollo(${displayName})`;\n  }\n\n  if (!isBrowser || PageComponent.getInitialProps) {\n    WithApollo.getInitialProps = async (context: any) => {\n      const {\n        AppTree,\n        ctx: { res }\n      } = context;\n\n      // Run all GraphQL queries in the component tree\n      // and extract the resulting data\n      const apolloClient = (context.ctx.apolloClient = initApolloClient({}));\n\n      const pageProps = PageComponent.getInitialProps\n        ? await PageComponent.getInitialProps(context)\n        : {};\n\n      // Only on the server\n      if (!isBrowser) {\n        // When redirecting, the response is finished.\n        // No point in continuing to render\n        if (res && res.finished) {\n          return {};\n        }\n\n        if (!isBrowser) {\n          try {\n            // Run all GraphQL queries\n            const { getDataFromTree } = await import(\"@apollo/react-ssr\");\n            await getDataFromTree(\n              <AppTree\n                pageProps={{\n                  ...pageProps,\n                  apolloClient\n                }}\n                apolloClient={apolloClient}\n              />\n            );\n          } catch (error) {\n            // Prevent Apollo Client GraphQL errors from crashing SSR.\n            // Handle them in components via the data.error prop:\n            // https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-query-data-error\n            console.error(\"Error while running `getDataFromTree`\", error);\n          }\n        }\n\n        // getDataFromTree does not call componentWillUnmount\n        // head side effect therefore need to be cleared manually\n        Head.rewind();\n      }\n\n      // Extract query data from the Apollo store\n      const apolloState = apolloClient.cache.extract();\n\n      return {\n        ...pageProps,\n        apolloState\n      };\n    };\n  }\n\n  return WithApollo;\n}\n\nlet apolloClient: ApolloClient<NormalizedCacheObject> | null = null;\n\n// Polyfill fetch() on the server (used by apollo-client)\nif (!isBrowser) {\n  (global as any).fetch = fetch;\n}\n\n/**\n * Creates and configures the ApolloClient\n * @param  {Object} [initialState={}]\n * @param  {Object} config\n */\nfunction createApolloClient(initialState: any = {}) {\n  const httpLink = createHttpLink({\n    uri: process.env.BACKEND_API_PATH\n  });\n\n  const wsLink = isBrowser\n    ? new WebSocketLink({\n        uri: `${process.env.BACKEND_WS_PATH}`,\n        options: {\n          reconnect: true\n        }\n      })\n    : null;\n\n  const refreshLink = new TokenRefreshLink({\n    accessTokenField: \"accessToken\",\n    isTokenValidOrUndefined: () => {\n      const token = getAccessToken();\n\n      if (!token) {\n        return true;\n      }\n\n      try {\n        const { exp } = jwtDecode(token);\n        if (Date.now() >= exp * 1000) {\n          return false;\n        } else {\n          return true;\n        }\n      } catch {\n        return false;\n      }\n    },\n    fetchAccessToken: () => {\n      const token = getAccessToken();\n\n      return fetch(`${process.env.BACKEND_API_PATH}/refresh_token`, {\n        method: \"POST\",\n        headers: {\n          Authentication: `Bearer ${token}`\n        }\n      });\n    },\n    handleFetch: accessToken => {\n      setAccessToken(accessToken);\n    },\n    handleError: err => {\n      console.error(err);\n      Router.replace(\"/login\");\n    }\n  });\n\n  const splitLink = isBrowser\n    ? split(\n        ({ query }) => {\n          const definition = getMainDefinition(query);\n          return (\n            definition.kind === \"OperationDefinition\" &&\n            definition.operation === \"subscription\"\n          );\n        },\n        wsLink as any,\n        httpLink\n      )\n    : httpLink;\n\n  const errorLink = onError(({ graphQLErrors, networkError }) => {\n    if (graphQLErrors)\n      graphQLErrors.map(({ message, path }) => {\n        console.log(`[GraphQL error] Query: ${path}, ${message}`);\n        const response = JSON.parse(message);\n        if (isBrowser && response.status === 401) {\n          Router.replace(\"/login\");\n        }\n      });\n    if (networkError) {\n      console.log(`[Network error]: ${networkError}`);\n      if (isBrowser) {\n        alert(\"서버 점검 중입니다.\");\n        Router.replace(\"/login\");\n      }\n    }\n  });\n\n  const authLink = setContext((_, { headers }) => {\n    const token = getAccessToken();\n    return {\n      headers: {\n        ...headers,\n        Authorization: `Bearer ${token}`\n      }\n    };\n  });\n\n  const link = [authLink, errorLink, splitLink];\n\n  if (isBrowser) {\n    link.push(refreshLink);\n  }\n\n  return new ApolloClient({\n    connectToDevTools: isBrowser,\n    ssrMode: !isBrowser, // Disables forceFetch on the server (so queries are only run once)\n    //link: errorLink.concat(authLink.concat(isBrowser ? httpLink : splitLink)),\n    link: ApolloLink.from(link),\n    cache: new InMemoryCache().restore(initialState)\n  });\n}\n\n// export function initializeApollo(initialState: any, options: Options) {\n//   // Make sure to create a new client for every server-side request so that data\n//   // isn't shared between connections (which would be bad)\n//   if (!isBrowser) {\n//     return createApolloClient(initialState, options);\n//   }\n\n//   // Reuse client on the client-side\n//   if (!apolloClient) {\n//     apolloClient = createApolloClient(initialState, options);\n//   }\n\n//   return apolloClient;\n// }\n\n/**\n * Always creates a new apollo client on the server\n * Creates or reuses apollo client in the browser.\n */\nfunction initApolloClient(initialState: any) {\n  // Make sure to create a new client for every server-side request so that data\n  // isn't shared between connections (which would be bad)\n  if (!isBrowser) {\n    return createApolloClient(initialState);\n  }\n\n  // Reuse client on the client-side\n  if (!apolloClient) {\n    // setAccessToken(cookie.parse(document.cookie).test);\n    apolloClient = createApolloClient(initialState);\n  }\n\n  return apolloClient;\n}\n"]},"metadata":{},"sourceType":"module"}